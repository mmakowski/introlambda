[file]
slides.pdf
[duration]
35
[end_user_slide]
1
[notes]
### 1
I'm a software developer
a number of years working on banking systems, mostly in Java, recently Scala
curious about ways of making correct and maintainable software
keep hearing about various tools that are supposed to make it easier: purity, category theory, dependent types
some of the terminology and concepts might be intimidating
fortunately, underpinning most of this is a simple formalism: lambda calculus

### 2
This is going to be a basic introduction

I do not assume any prior computer science knowledge

If anything is not clear please ask -- it is my fault, not yours

Core topics
  basics of untyped lambda calculus
  programming in lambda calculus

If we have time we can do the others
### 3
>> Who knows what an AST is? Context-free grammar?

Explain:
expr ::= n | (<expr> + <expr>) | (<expr> * <expr>)

(2+(3*4))

draw AST
### 4

Lambda terms consist of three things: variables/abstractions/applications

### 5
This is a term that consists of a single variable, v1

>> What does its AST look like?
### 6
A single variable node
### 7
application of x to y

not a valid term, missing parentheses

convention: application binds to the left

>> How many nodes is AST going to have?
### 8
The root is an application; its children are two variables, x and y
### 9
abstraction

again, we omit redundant parentheses

full-stop is opening parenthesis that extends until the end of subterm
### 10
abstraction has just one subterm, so the tree has two nodes
### 11
>> What type of node is in the root of this tree?
### 13
variable under abstraction is bound by it

unbound occurrence: free

terms with no free occurrences: combinators

### 15
same variable can be both free and bound in a term
### 16
For convenience terms are written as linear expressions (like arithmetics)

What operations can we perform on those trees?
### 17
rename bound variables (not find/replace!)

can't rename to y (free variable)

alpha conversion
### 18
remove abstraction under application
replace *free* occurrences of x in M

### 19
1. x y is M, \z.z is N
2. z is M, y is N

:: bound occurrence example: (\a.a (\a.a)) b
:: multiple redexes example: (\a.(\b.b) a) ((\c.\d.d) \f.f)

in which order do we reduce? Reduction strategies.
### 20
show on previous example: (\a.(\b.b) a) ((\c.\d.d) \f.f)
that's where call-by-name param in scala comes from
does the order of reductions matter?
### 21
confluence (for unrestricted beta-reduction)
does every reduction chain terminate: no: (\x.xx) (\x.xx) (Omega)
### 22
mental model of what an abstraction represents
### 23
+ and * -- binary functions 
lambda abstraction -- definition of anonymous function
beta-reduction: function evaluation
### 24
FP = programming with mathematical functions
semantics -> we will investigate functional programming

